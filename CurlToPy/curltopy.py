import shlex
import typer
from typing_extensions import Annotated
from typing import List, Optional
from rich import print

class CurlConverter:
    def __init__(self, filePath):
        self.filePath = filePath

    def convert(self):
        with open(self.filePath, 'r') as file:
            curlCommand = file.read().strip()
        
        return self._parseCurlCommand(curlCommand)

    def _parseCurlCommand(self, curlCommand):
        tokens = shlex.split(curlCommand)

        url = None
        method = 'GET'
        headers = {}
        data = None

        for i, token in enumerate(tokens):
            if token.startswith('http'):
                url = token
            elif token == '-H':
                header = tokens[i+1]
                key, value = header.split(':', 1)
                headers[key.strip()] = value.strip()
            elif token == '-d':
                data = tokens[i+1]
                method = 'POST'
            elif token == '-X':
                method = tokens[i+1]

        return {
            'url': url,
            'method': method,
            'headers': headers,
            'data': data
        }

class PyOutputWriter:
    def __init__(self, outputFilePath, data, noRequests, noThreads, printresponse, verbose):
        self.outputFilePath = outputFilePath

        self.url = data['url']
        self.method = data['method']
        self.headers = data['headers']
        self.data = '' if data['data'] is None else data['data']

        self.noRequests = noRequests
        self.noThreads = noThreads
        self.printresponse = printresponse
        self.verbose = verbose
    
    def write(self):
        with open(self.outputFilePath, 'w') as file:
            file.write(self._generateOutput())
    
    def _generateOutput(self):
        output = '#\n'
        output += '# Automatically generated by ReqToPy\n'
        output += '#\n\n'

        output += '# Imports\n'

        output += 'import requests\n'

        if self.noThreads != 1:
            output += 'import concurrent.futures\n'

        if self.noThreads != 1 and self.noRequests != -1:
            output += 'import threading\n'

        if self.verbose:
            output += 'from rich import print\n'

        if self.noRequests > 1:
            output += 'from rich.progress import track\n'

        output += '\n'
        output += '# Preset variables\n'

        if self.noThreads != 1:
            output += f'THREADS = {self.noThreads}\n\n'

        output += f'URL = "{self.url}"\n'
        output += f'METHOD = "{self.method}"\n'
        output += f'HEADERS = {str(self.headers).replace("',", "',\n")}\n'
        output += f'DATA = "{self.data}"\n'

        if self.noRequests != -1:
            output += '\n'
            output += f'NO_REQUESTS = {self.noRequests}\n' 

        output += '\n'
        output += '# Functions\n'

        output += 'def sendRequest(url, method, headers, data):\n'

        if self.noRequests != -1:
            indent = '    '
        else:
            output += '    while True:\n'
            indent = '        '

        if self.verbose or self.printresponse:
            output += f'{indent}response = requests.request(method, url, headers=headers, data=data)\n\n'
        else:
            output += f'{indent}requests.request(method, url, headers=headers, data=data)\n'

        if self.verbose:
            output += f'{indent}if response.ok:\n'
            output += f'{indent}    print(f"[green]{{response.status_code}}")\n'
            output += f'{indent}else:\n'
            output += f'{indent}    print(f"[red]{{response.status_code}}")\n'
        
        if self.printresponse:
            output += f'{indent}print(response.text)\n'

        if self.noRequests != -1:
            output += '\n    return\n'
            
        output += '\n'

        output += 'def main():\n'

        output += '    print("Sending requests...")\n\n'

        if self.noThreads != 1 and self.noRequests != -1:
            output += '    with concurrent.futures.ThreadPoolExecutor(max_workers = THREADS) as executor:\n'
            output += '        futures = [executor.submit(sendRequest, URL, METHOD, HEADERS, DATA) for _ in range(NO_REQUESTS)]\n'
            output += '        concurrent.futures.wait(futures)\n'
            
        elif self.noThreads != 1:
            output += '    with concurrent.futures.ThreadPoolExecutor(max_workers = THREADS) as executor:\n'
            output += '        futures = [executor.submit(sendRequest, URL, METHOD, HEADERS, DATA) for _ in range(THREADS)]\n'
            output += '        concurrent.futures.wait(futures)\n'

        elif self.noRequests != -1:
            output += '    for _ in range(NO_REQUESTS):\n'
            output += '        sendRequest(URL, METHOD, HEADERS, DATA)\n'
        
        else:
            output += '    sendRequest(URL, METHOD, HEADERS, DATA)\n'

        output += '\n    print("Done!")\n\n'

        output += 'if __name__ == "__main__":\n'
        output += '    main()'

        return output

def setupHelper():
    print("[bold yellow]Setup helper[/bold yellow]\n")

    while True:
        print("Enter the path to the cURL request file:")
        requestpath = input("Path: ")

        try:
            with open(requestpath, 'r'):
                break
        except:
            print("\n[bold red]Invalid path. Try again.[/bold red]\n")

    print("\nEnter the path to the output Python file:")
    outputpath = input("Path: ")

    while True:
        print("\nEnter the number of requests to send. Leave blank for infinite:")
        requests = input("Requests: ")
        try:
            if requests == '':
                requests = -1
            else:
                requests = int(requests)
            
            break
        except:
            print("\n[bold red]Invalid input. Try again.[/bold red]\n")

    while True:
        print("\nEnter the number of threads to use. Leave blank for unthreadded:")
        threads = input("Threads: ")
        try:
            if threads == '':
                threads = 1
            else:
                threads = int(threads)

            break
        except:
            print("\n[bold red]Invalid input. Try again.[/bold red]\n")

    printresponse = input("Print the response to the request? [y/N]: ").lower() == "y"

    print("\n[bold yellow]Setup complete[/bold yellow]\n")

    return requestpath, outputpath, requests, threads, printresponse

def main(requestpath: Annotated[Optional[str], typer.Argument(help="Path to file with saved cURL command")] = None,
         outputpath: Annotated[Optional[str], typer.Argument(help="Path of file to output python script")] = 'output.py',
         requests: Annotated[int, typer.Option(help="Number of requests to send in generated script")] = 1,
         threads: Annotated[int, typer.Option(help="Number of threads to use in generated script")] = 1,
         printresponse: Annotated[bool, typer.Option(help="Print the reponse to the request")] = False,
         verbose: Annotated[bool, typer.Option()] = False):
    
    print("\n[ [bold blue][yellow]cURL[/yellow] to [yellow]Python[/yellow] Converter[/bold blue] ]\n")

    if requestpath is None:
        requestpath, outputpath, requests, threads, printresponse = setupHelper()
    else:
        try:
            with open(requestpath, 'r'):
                pass
        except:
            print("\n[bold red]Invalid path.[/bold red]")
            exit()

    curlConverter = CurlConverter(requestpath)
    data = curlConverter.convert()

    outputWriter = PyOutputWriter(outputpath, data, requests, threads, printresponse, verbose)
    outputWriter.write()
    
    print("Done!")
    print(f"File generated at: [[bold yellow]{outputpath}[/bold yellow]]")

if __name__ == "__main__":
    typer.run(main)